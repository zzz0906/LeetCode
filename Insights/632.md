## 632. Smallest Range Covering Elements from K Lists
You have k lists of sorted integers in non-decreasing order. Find the smallest range that includes at least one number from each of the k lists.

We define the range [a, b] is smaller than range [c, d] if b - a < d - c or a < c if b - a == d - c.

Example 1:

Input: nums = \[[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]
Output: \[20,24]
Explanation: 
List 1: [4, 10, 15, 24,26], 24 is in range [20,24].
List 2: [0, 9, 12, 20], 20 is in range [20,24].
List 3: [5, 18, 22, 30], 22 is in range [20,24].
Example 2:

Input: nums = \[[1,2,3],[1,2,3],[1,2,3]]
Output: [1,1]
 

Constraints:

nums.length == k
1 <= k <= 3500
1 <= nums[i].length <= 50
-105 <= nums[i][j] <= 105
nums[i] is sorted in non-decreasing order.

each list represent the range. First, assume we can sort each list to get smaller -> bigger a1,a2,a3...an
a1 -> an
b1 -> bn
...

The best overlap we can get is to find the overlap area first. Can we use binary search for this problem?
Assume overlap area is x,y. But the search space is two dimension. 

I have no idea how to solve this problem. Let's check the std. Ohops, heap again.

First, the original array is sorted. Second, we can use heap to find the smallest range. First, we put the smallest element of each array into the heap. Then, we pop the smallest element and push the next element of the array. We keep doing this until one of the array is empty. We can use a variable to keep track of the max value of the heap. The reason why we keep poping the smallest until an array is empty, it means the max value of this array is still the smallest in the heap. The left range cannot be bigger than this. So this value is the left range lower bound. But the question is what is the right interval. the right interval will be the max value in the heap. 

So why don;t we do this, find the minimal of max value $k$ for each list and then binary search to find the minimal of value greater than that $k$? N*logN either way. Because it's wrong!! The k may not be the right interval after put into the heap. Still need a heap to solve this. The heap maintain the smallest range. (smallest in heap, biggest in heap). Each time we pop out a element to make it smaller, we need to push one element from the original list back.
 