## Distribute Candies

DP, right? So DP style.

Given the integer array candyType of length n, return the maximum number of different types of candies she can eat if she only eats n / 2 of them.

-10^5 <= candyType[i] <= 10^5

Bucket?

200000 = [-100000,100000] => [0,200000]

we tag 1 and iterate over 200000.

## Intersection of Two Linked Lists

n^2 iterations?

Find the first same node?

160. I have done it before. let me just copy my code.

## Remove Palindromic Subsequences

Given a string s consisting only of letters 'a' and 'b'. In a single step you can remove one palindromic subsequence from s.

Return the minimum number of steps to make the given string empty.

A string is a subsequence of a given string, if it is generated by deleting some characters of a given string without changing its order.

A string is called palindrome if is one that reads the same backward as well as forward.

I seem to need to find the longest palindromic subsequeces?

NOPE...it cannot let remove time be shortest.

I think it need dp or brute force.

s only consists of letters 'a' and 'b'

aabbaa

HINT: Are subsequences composed of only one type of letter always palindrome strings ?

Fuck...so the maximum answer is 2.

we only need to detect it can be removed by once. It's a palindrome!

AC...

## Coin Change

You are given coins of different denominations and a total amount of money amount

You may assume that you have an infinite number of each kind of coin.

It's a DP?

It's hard to think the equation in a short time.

DP[i] = DP[i - coins[i]] + 1

Genius! Max = amount + 1; dp[0] = 0;

## Swapping Nodes in a Linked List

You are given the head of a linked list, and an integer k.

Return the head of the linked list after swapping the values of the kth node from the beginning and the kth node from the end (the list is 1-indexed).

1 2 3 4 5 ... kth

we can find the k-1; k; k+1; and the length - (k-1) ; length - k; length - (k+1);

we only need to do is let k-1 -> next = reverse k; reverse k -> next = k + 1; and the length - (k+1) -> next = k; k->next = length - (k-1);

let me see the std. my solution still has some problems.

may be the k and reverse k is the adjacent nodes. 

the std swap these two nodes's value directly...It's correct and meaningful?

two pointers and the first one called p1, the second called p2. p1 to the k, then the rest is length - k; so if the p2 go on the length - k then the p2 must be the reverse k. For example, p1 is 4th; 1 2 3 4] 5 6; then the revse 4 is 2th, so we can let p1 pass to the end (5,6) and in each step let p2 also go on a step. 

## Best Time to Buy and Sell Stock with Transaction Fee

This problem agian! DP. hard to think transaction equation.

sold[i] the maximum profit sold in ith days.

hold[i] the maximum profit if we hold this stock.

and transaction:

sold[i] = max(sold[i - 1], hold[i - 1] + prices[i] - fee);

hold[i] = max(hold[i - 1], sold[i - 1] - prices[i]);