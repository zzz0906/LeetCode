## Distribute Candies

DP, right? So DP style.

Given the integer array candyType of length n, return the maximum number of different types of candies she can eat if she only eats n / 2 of them.

-10^5 <= candyType[i] <= 10^5

Bucket?

200000 = [-100000,100000] => [0,200000]

we tag 1 and iterate over 200000.

## Intersection of Two Linked Lists

n^2 iterations?

Find the first same node?

160. I have done it before. let me just copy my code.

## Remove Palindromic Subsequences

Given a string s consisting only of letters 'a' and 'b'. In a single step you can remove one palindromic subsequence from s.

Return the minimum number of steps to make the given string empty.

A string is a subsequence of a given string, if it is generated by deleting some characters of a given string without changing its order.

A string is called palindrome if is one that reads the same backward as well as forward.

I seem to need to find the longest palindromic subsequeces?

NOPE...it cannot let remove time be shortest.

I think it need dp or brute force.

s only consists of letters 'a' and 'b'

aabbaa

HINT: Are subsequences composed of only one type of letter always palindrome strings ?

Fuck...so the maximum answer is 2.

we only need to detect it can be removed by once. It's a palindrome!

AC...

## Coin Change

You are given coins of different denominations and a total amount of money amount

You may assume that you have an infinite number of each kind of coin.

It's a DP?

It's hard to think the equation in a short time.

DP[i] = DP[i - coins[i]] + 1

Genius! Max = amount + 1; dp[0] = 0;

## Swapping Nodes in a Linked List

You are given the head of a linked list, and an integer k.

Return the head of the linked list after swapping the values of the kth node from the beginning and the kth node from the end (the list is 1-indexed).

1 2 3 4 5 ... kth

we can find the k-1; k; k+1; and the length - (k-1) ; length - k; length - (k+1);

we only need to do is let k-1 -> next = reverse k; reverse k -> next = k + 1; and the length - (k+1) -> next = k; k->next = length - (k-1);

let me see the std. my solution still has some problems.

may be the k and reverse k is the adjacent nodes. 

the std swap these two nodes's value directly...It's correct and meaningful?

two pointers and the first one called p1, the second called p2. p1 to the k, then the rest is length - k; so if the p2 go on the length - k then the p2 must be the reverse k. For example, p1 is 4th; 1 2 3 4] 5 6; then the revse 4 is 2th, so we can let p1 pass to the end (5,6) and in each step let p2 also go on a step. 

## Best Time to Buy and Sell Stock with Transaction Fee

This problem agian! DP. hard to think transaction equation.

sold[i] the maximum profit sold in ith days.

hold[i] the maximum profit if we hold this stock.

and transaction:

sold[i] = max(sold[i - 1], hold[i - 1] + prices[i] - fee);

hold[i] = max(hold[i - 1], sold[i - 1] - prices[i]);

## Generate Random Point in a Circle

Given the radius and x-y positions of the center of a circle, write a function randPoint which generates a uniform random point in the circle.

Just random; if the point is outer of the circle, just random again!

!: do not add srand in the rand; because in each turn it will use another random seed and generate a different random number.

After delete it then AC!

## Wiggle Subsequence

Given an integer array nums, return the length of the longest wiggle sequence.

A wiggle sequence is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence.

A subsequence is obtained by deleting some elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order.

Follow up: Could you solve this in O(n) time?

let me try some examples

1 17 5 10,13,15, 10,5 ,16

maybe we shall use brute force? or dp

f[i] = 1..j => n^2 problem

how to get o(n) solution? the std use greedy and two pointer

the std use two pointer. and if current value > last then increase pointer = decrease pointer + 1

also, if current value < last one then decrease pointer = increase pointer + 1

so clever in this way!